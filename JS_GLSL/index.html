<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">          
    <title>Index</title>
    <style>
      body {background-color: #000;overflow: hidden;margin: 0px;padding: 0px;}
    </style>
  </head>
  <body>
    <div class="divcanvas">
      <canvas id="canvas"></canvas>
    </div>
    <script>

"use strict";

const input = {
  mx:0,
  my:0,
  lsx:0,
  lsy:0,
  gp:false,
  elem: null,
  update: function() {
    for (const gamepad of navigator.getGamepads()) {
      if (!gamepad) continue;
      for (const [i, button] of gamepad.buttons.entries()) {
        if (button.pressed) {
          //console.log(`Button ${i} [PRESSED]`);
        }
      }
      for (const [i, axis] of gamepad.axes.entries()) {
        //console.log(`${i}: ${axis.toFixed(4)}`);
        //console.log("value", axis + 1);
        if(i==0){input.lsx=axis}
        if(i==1){input.lsy=axis}
        if(Math.abs(input.lsx)<0.1){input.lsx=0}
        if(Math.abs(input.lsy)<0.1){input.lsy=0}
      }
    }
  },
  setMousePosition:function(e) {
    const rect = input.elem.getBoundingClientRect();
    input.mx = e.clientX - rect.left;
    input.my = rect.height - (e.clientY - rect.top) - 1;  // bottom is 0 in WebGL
    //input.mx = input.mx*rr.pixscale;
    //input.my = input.my*rr.pixscale;
  },
  init:function(){
    this.elem = document.querySelector('.divcanvas');
    this.elem.addEventListener('mouseover', rr.requestFrame);
    this.elem.addEventListener('mouseout', rr.cancelFrame);
    this.elem.addEventListener('mousedown', physics.slow);
    this.elem.addEventListener('mouseup', physics.fast);
    this.elem.addEventListener('mousemove', this.setMousePosition);
    this.elem.addEventListener('touchstart', (e) => {
      e.preventDefault();
      rr.requestFrame();
    }, {passive: false});
    this.elem.addEventListener('touchmove', (e) => {
      e.preventDefault();
      this.setMousePosition(e.touches[0]);
    }, {passive: false});
    this.elem.addEventListener('touchend', (e) => {
      e.preventDefault();
      rr.cancelFrame();
    }, {passive: false});
    window.addEventListener("gamepadconnected", (e) => {
      input.gp = true;
      var eg = e.gamepad;
      console.log("GP %d: %s. %d btns, %d axes.",eg.index,eg.id,eg.buttons.length,eg.axes.length,);
    });
  }
}

const shaders = {
  vs:`#version 300 es
    // an attribute is an input (in) to a vertex shader.
    // It will receive data from a buffer
    in vec4 a_position;

    // all shaders have a main function
    void main() {

      // gl_Position is a special variable a vertex shader
      // is responsible for setting
      gl_Position = a_position;
    }
  `,
  fs:`#version 300 es
    precision highp float;
    uniform vec2 iResolution;
    uniform vec2 iMouse;
    uniform float iTime;
    uniform vec2 pos0;
    uniform vec3 pos1;
    uniform vec3 pos2;
    uniform vec3 pos3;
    uniform vec3 pos4;
    uniform vec3 pos5;
    uniform vec3 pos6;
    uniform vec3 pos7;
    uniform vec3 pos8;
    uniform vec3 pos9;
    uniform vec3 pos10;
    uniform int player;
    uniform int hasball;
    out vec4 outColor;

#define numrobs 11
#define numlights 4

#define white vec3(1.)
#define pink vec3(.95,.75,.75)
#define pgreen vec3(.7,.9,.7)
#define pblack vec3(.6,.6,.6)
#define black vec3(.0)
#define pgrey vec3(0.85)
#define pred vec3(1., .5, .5)

float pixel = 0.0;
vec4 courtprox = vec4(0.0);
vec2 uv = vec2(0.0);
float ar = 0.0;
float f = 0.0; 
float border = 0.05;
float bar = 1.0;

struct light
{
    vec3 colour;
    vec3 position;
    vec3 difference;
    vec3 amount;
    vec2 shadow;
    float dist;
    float intensity;
    bool casts;
    bool ison;
};

struct Rob
{
    vec3 position;
    vec3 colourA;
    vec3 colourB;
    float rotation;
    float radius;
    bool ison;
};

vec3 getGroundColour(){
    float linewidth = 0.01;
    float hlinewidth = linewidth/2.0;
    float rhlinewidth = hlinewidth + pixel/2.0;
    vec3 rcol = pgrey;
    if(courtprox.x>-linewidth&&courtprox.x<=0.0||abs(courtprox.y)<linewidth||courtprox.z>-linewidth&&courtprox.z<=0.0||abs(courtprox.w)<linewidth){
        rcol = white;
    }
    float crad = 0.2;
    float dfc = distance(uv, vec2(ar/2.0, 0.5));
    float crdiff = dfc-crad;
    if(crdiff<rhlinewidth ){
        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));
        rcol = mix(white, pgrey, f);
    }

    if(crdiff>=hlinewidth-pixel&&abs(uv.x - (ar/2.0))<=hlinewidth){
        rcol = white;
    }
    dfc = distance(uv, vec2(border*bar, 0.5));
    crdiff = dfc-crad;
    if(crdiff<rhlinewidth ){
        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));
        rcol = mix(white, rcol, f);
    }
    dfc = distance(uv, vec2(ar-(border*bar), 0.5));
    crdiff = dfc-crad;
    if(abs(crdiff)<rhlinewidth ){
        f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));
        rcol = mix(white, rcol, f);
    }
    return rcol;
}

bool outputMode = false; vec3 outputColour;
void outputValue (in float value){
    outputMode = true;
    if ( value >= 0.0 && value <= 1.0 )
        { outputColour = vec3(value, value, value); }
        else if ( value < 0.0 && value > -1.0 )
        { outputColour = vec3(0.0, 0.0, -value ); }
        else if ( value > 1.0 )
        { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }
        else if ( value < -1.0 )
        { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }
} 
void outputValue (in vec3 value){outputMode = true;outputColour = value;}

vec3 contrast(vec3 color, float value) {
  return 0.5 + value * (color - 0.5);
}

vec3 gammaCorrection (vec3 colour, float gamma) {
  return pow(colour, vec3(1. / gamma));
}

float linePointLength( in vec3 P, in vec3 A, in vec3 B ){
    vec3 AB = B-A;
    float lenAB = length(AB);
    vec3 D = AB/lenAB;
    vec3 AP = P-A;
    float d = dot(D, AP);
    vec3 X = A + D * dot(P-A, D);
    if(X.z<0.0){return 10.0;} else {return length(X-P);}
}

vec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){
    vec3 AB = B-A;
    float lenAB = length(AB);
    vec3 D = AB/lenAB;
    vec3 AP = P-A;
    float d = dot(D, AP);
    vec3 X = A + D * dot(P-A, D);
    return X;
}

// SD Functions from https://iquilezles.org/articles/distfunctions2d/

float sdBox( in vec2 p, in vec2 b )
{
    vec2 d = abs(p)-b;
    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
}

float sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){
  vec2 e0 = p1 - p0;
  vec2 e1 = p2 - p1;
  vec2 e2 = p0 - p2;

  vec2 v0 = p - p0;
  vec2 v1 = p - p1;
  vec2 v2 = p - p2;

  vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );
  vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );
  vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );
    
    float s = e0.x*e2.y - e0.y*e2.x;
    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),
                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),
                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));

  return -sqrt(d.x)*sign(d.y);
}
float dot2( vec2 v ) { return dot(v,v); }
float sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )
{    
    vec2 a = B - A;
    vec2 b = A - 2.0*B + C;
    vec2 c = a * 2.0;
    vec2 d = A - pos;
    float kk = 1.0/dot(b,b);
    float kx = kk * dot(a,b);
    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;
    float kz = kk * dot(d,a);      
    float res = 0.0;
    float p = ky - kx*kx;
    float p3 = p*p*p;
    float q = kx*(2.0*kx*kx-3.0*ky) + kz;
    float h = q*q + 4.0*p3;
    if( h >= 0.0) 
    { 
        h = sqrt(h);
        vec2 x = (vec2(h,-h)-q)/2.0;
        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
        float t = clamp( uv.x+uv.y-kx, 0.0, 1.0 );
        res = dot2(d + (c + b*t)*t);
    }
    else
    {
        float z = sqrt(-p);
        float v = acos( q/(p*z*2.0) ) / 3.0;
        float m = cos(v);
        float n = sin(v)*1.732050808;
        vec3  t = clamp(vec3(m+m,-n-m,n-m)*z-kx,0.0,1.0);
        res = min( dot2(d+(c+b*t.x)*t.x),
                   dot2(d+(c+b*t.y)*t.y) );
    }
    return sqrt( res );
}

// Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com
// You may view and edit this code (with this message intact) only on Shadertoy.
// Anything else requires my permission.

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    uv = fragCoord/iResolution.y;
    ar = iResolution.x/iResolution.y;
    float height = 0.0;
    pixel = 1./iResolution.y;
    float mTime = mod(iTime, 6.2832);
    bool ZoneRob = false;
    bool ZoneGround = false;
    bool ZoneWall = false;
    bool ZoneGoalWall = false;
    bool ZoneInsideWall = false;
    border = 0.05;
    bar = 1.0;
    vec4 courtyard = vec4( border*bar, border, ar-(border*bar), 1.0-border);
    courtprox = vec4( courtyard.x - uv.x, courtyard.y - uv.y, uv.x - courtyard.z, uv.y - courtyard.w);
    float goalwidth = 0.2;
    float goaltop = 0.5 + (goalwidth/2.0);  
    float goalbottom = 0.5 - (goalwidth/2.0);
    float goalprox = max((uv.y-goaltop), (goalbottom-uv.y));
    float wallheightfactor = 1.0;

    Rob Robs[numrobs];
    float dist = ar;
    int rindex = -1;
    vec2 centre = vec2(ar/2.0, 0.5);
    float radius = 0.0;
    float cradius = 0.34;
    vec2 centreL = vec2((ar/2.0)-(cradius),0.5);
    vec2 centreR = vec2((ar/2.0)+(cradius),0.5);
    float segment = 1.256637;
    float rightAng = 1.5708;
    float dradius = 0.048;
    float bradius = 0.02;
    vec2 distv; 
    vec3 normal = vec3(0.0,0.0,1.0);
    vec3 bgnormal = vec3(0.0,0.0,1.0); 
    bool flatTop = false;
    float theight = 0.0;
    float angle = 0.0;
    
    int activerobs = 11;

        vec3 pos[numrobs];
        pos[0] = vec3(pos0, 0.0);
        pos[1] = pos1;
        pos[2] = pos2;
        pos[3] = pos3;
        pos[4] = pos4;
        pos[5] = pos5;
        pos[6] = pos6;
        pos[7] = pos7;
        pos[8] = pos8;
        pos[9] = pos9;
        pos[10] = pos10;
        //for(int i=0;i<numrobs;i++){
            //pos[i].x = (ar/2.0) + (pos[i].x/10.0)*(ar/2.0);
            //pos[i].y = 0.5 + (pos[i].y/6.0)*0.5;
        //}


    for(int i=1;i<numrobs;i++){
    Robs[i].ison = false;
      if(i<activerobs){
        Robs[i].ison = true;
        Robs[i].radius = dradius;
        //angle = float(i) * segment;
        //vec2 rcentre = centreL;
        if(i>5){
            Robs[i].colourA = pgreen;
            Robs[i].colourB = pblack;
            //angle += mTime;
            //Robs[i].rotation = angle + rightAng;
            //rcentre = centreR;
          } else {
                Robs[i].colourA = pink;
                Robs[i].colourB = white;
                //angle -= mTime;
                //Robs[i].rotation = angle - rightAng;
            }
        //Robs[i].position = vec3( rcentre.x + (cradius * cos(angle)), rcentre.y + (cradius * sin(angle)), 0.0);
        Robs[i].position = vec3( pos[i].xy, 0.0);
        Robs[i].rotation = pos[i].z - rightAng;
        } 
    }
    
    int player = 1;
    
    int tracter = hasball;
    int tractee = 0;
    bool tracting = false;
    if(tracter>0){tracting = true;}
    
    float sinw = sin(mTime*50.0);
    Robs[0].position = vec3( pos[0].xy, bradius);
    if(tractee==0 &&tracting){
      Robs[0].position.x += sinw/400.0;
      Robs[0].position.y -= sinw/400.0;
        //float balldist = dradius+bradius*3.;
        //balldist += sinw/200.0;
        //Robs[0].position = vec3( Robs[hasball].position.x + (balldist * cos(Robs[hasball].rotation)), Robs[hasball].position.y + (balldist * sin(Robs[hasball].rotation)), bradius);
    } else {
        //Robs[0].position = vec3(ar/4., 0.2, 0.);
    }
    Robs[0].radius = bradius;
    Robs[0].ison = true;
    Robs[0].colourA = vec3(1.2);
    Robs[player].colourA = pred;
    vec3 bgcol;
    vec3 fgcol; 
    vec3 col = white;  
    vec2 robambient = vec2(1.0, 1.0);
    
    light lights[numlights];
    lights[0] = light(vec3(1.0,1.0,1.0),vec3(ar*.5, .5 ,.6),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.1, true, true);
    lights[1] = light(vec3(1.0,0.3,0.3),vec3(ar*-0.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.03, true, true);
    lights[3] = light(vec3(0.3,1.0,0.3),vec3(ar*1.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.025, true, false);
    
    lights[2] = light(vec3(0.2,0.2,0.9),vec3(0.0),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.0007, false, false);
    
    lights[2].position = Robs[tractee].position;
    //lights[2].position.z = 0.005;
    lights[2].ison = tracting;
    if(uv.x>=ar/2.0){
        lights[1] =  lights[3]; lights[1].ison = true;
    }
        vec3 tcol = vec3(0.2,0.2,0.6);
    if(tracter<6){tcol = vec3(0.5,0.2,0.2);}else{tcol = vec3(0.2,0.5,0.2);}
    lights[2].colour = tcol;

    if(courtprox.w>0.0 && courtprox.w*bar>courtprox.z && courtprox.w*bar>courtprox.x){
        bgcol = pgrey;
        bgnormal = vec3(0.0,-1.0,0.0);
        ZoneWall = true;
        height = courtprox.w * wallheightfactor;
    } else if(courtprox.y>0.0 && courtprox.y*bar>courtprox.z && courtprox.y*bar>courtprox.x){
        bgcol = pgrey;
        bgnormal = vec3(0.0,1.0,0.0);
        ZoneWall = true;
        height = courtprox.y *  wallheightfactor;
    } else if(goalprox>0.0 && courtprox.x>0.0 || courtprox.x>(border*bar)/2.0){
        bgcol = pgrey;
        bgnormal = vec3(1.0,0.0,0.0);
        ZoneWall = true; ZoneGoalWall = true;
        float cph = courtprox.x/2.2;
        if(goalprox<cph && courtprox.x<(border*bar)/2.0 ){
            ZoneInsideWall = true;
            height = goalprox * wallheightfactor;
            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);} 
        } else {
            height = courtprox.x * wallheightfactor;      
        }
    } else if(goalprox>0.0 && courtprox.z>0.0 || courtprox.z>(border*bar)/2.0){
        bgcol = pgrey;
        bgnormal = vec3(-1.0,0.0,0.0);
        ZoneWall = true; ZoneGoalWall = true;
        if(goalprox<courtprox.z/2.2 && courtprox.z<(border*bar)/2.0 ){
            ZoneInsideWall = true;
            height = goalprox * wallheightfactor;
            if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);}
        } else {
            height = courtprox.z * wallheightfactor;
          
        }
    } else {
        ZoneGround = true;
        bgcol = getGroundColour();
        bgnormal = vec3(0.0,0.0,1.0);
    }
    
    float limA = courtyard.x;
    float limB = courtprox.x;
    
    if(uv.x>ar/2.0){ limA = courtyard.z; limB = courtprox.z; }
    
    float lightATG = (goaltop-lights[1].position.y)/(lights[1].position.x-limA);
    float lightATGdist = ( (lights[1].position.x - uv.x) * lightATG) -  (uv.y-lights[1].position.y);
    float lightABG = (goalbottom-lights[1].position.y)/(lights[1].position.x-limA);
    float lightABGdist =    (uv.y-lights[1].position.y)-( (lights[1].position.x - uv.x) * lightABG);
    float lightAdist = lightABGdist*lightATGdist;
    
    lights[1].shadow.x = 1.0;
    
    if(goalprox<0.0||ZoneInsideWall){lights[1].shadow.x = 0.0;} else if(lightAdist>0.0){
        lights[1].shadow.x = 0.0;
        f = smoothstep(0.0, 0.2*-limB, lightAdist);
        lights[1].shadow.x = mix(1.0, 0.0, f);
    }
    
    lights[1].shadow.y = lights[1].shadow.x;
    
    for(int i=0;i<numrobs;i++){
        if(Robs[i].ison){
        float bdist = distance(uv, Robs[i].position.xy);
        if(bdist<dist){dist=bdist;}
        float edgedist = distance(uv, Robs[i].position.xy) + (Robs[i].position.z);
        if(bdist<Robs[i].radius){
            dist=bdist;
            radius = Robs[i].radius;
            height = sqrt((radius*radius)-(dist*dist));
            ZoneRob = true;
            rindex = i;
            if(i>5){flatTop=true;}
            if(bdist<Robs[i].radius-pixel){ZoneGround = false;}
            robambient.y *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0));
        } else {
            robambient *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0));
        }
      }
    }
    
    if(ZoneRob){
        fgcol = Robs[rindex].colourA;
        centre = vec2(Robs[rindex].position.x, Robs[rindex].position.y);
        distv = uv - centre;
        normal = vec3(distv.x, distv.y, height)/radius;
        height+=Robs[rindex].position.z;
        
        if(flatTop){
            float tradius = radius/2.5;
            theight = sqrt((radius*radius)-(tradius*tradius));
            if(height>theight){
                height=theight;
                normal = vec3(0.0, 1.0, 0.0);
            }
            f = smoothstep(theight-0.01, theight, height);
            normal = mix(normal,vec3(0.0, 0.0, 1.0),  f);
            height = mix(height,theight,  f);
        }
        
        robambient.x *= (0.6 + normal.z/3.0);
        float rotation = Robs[rindex].rotation;
        if(rindex>0){
            float SpFoffset = radius*2.0;
            float SpBoffset = radius/1.0;
            float SpFheight = radius*-1.0;
            float SpBheight = radius*1.4;
            float SpWidth = radius/1.4;
            float SpLength = SpFoffset+SpBoffset;
            float SpHeight = SpBheight-SpFheight;
            vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation),  centre.y + SpFoffset * sin(rotation), 0.0);
            vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.y -= (SpWidth * cos(rotation));
            vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.y += (SpWidth * cos(rotation));
            vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), centre.y - SpBoffset * sin(rotation), 0.0);
            vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.y -= (SpWidth * cos(rotation));
            vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.y += (SpWidth * cos(rotation));
            float SpFD = linePointLength( vec3(uv.x, uv.y, 0.0), vec3(SpFl.x, SpFl.y, 0.0), vec3(SpFr.x, SpFr.y, 0.0) );
            float SpH = SpFheight + (SpHeight*(SpFD/SpLength));
            float inTri = sdTriangle(uv, SpFc.xy, SpBr.xy, SpBl.xy);
            
            float lineDist = linePointLength( vec3(uv.x, uv.y, 0.0) , vec3(SpBc.x, SpBc.y, 0.0)  , vec3(SpFc.x, SpFc.y, 0.0)  );
            
            float linewid =  radius*0.05;
            float linemid = abs((radius*0.45)-lineDist);
            if(linemid<linewid){fgcol=Robs[rindex].colourB;}
            if(linemid<linewid+pixel){
                f = smoothstep(linewid,linewid+pixel, linemid);
                fgcol = mix(Robs[rindex].colourB, fgcol, f);
            }
            if(rindex>5){
                if(SpFD<radius*2.0){
                    float linewid =  radius*0.05;
                    float linemid = abs((radius*+0.45)-dist);
                    if(linemid<linewid){fgcol=Robs[rindex].colourB;} else if(dist>(radius*+0.45)) {fgcol=Robs[rindex].colourA;}
                    if(linemid<linewid+pixel){
                        f = smoothstep(linewid,linewid+pixel, linemid);
                        fgcol = mix(Robs[rindex].colourB, fgcol, f);
                    }
                }
            } else {
                if(SpFD>radius*2.5&&lineDist<(radius*0.5)+pixel){
                    float linewid =  radius*0.05;
                    float linemid = abs((radius*+0.75)-dist);
                    if(linemid<linewid){fgcol=Robs[rindex].colourB;} else if(dist>(radius*+0.75)) {fgcol=Robs[rindex].colourA;}
                    if(linemid<linewid+pixel){
                        f = smoothstep(linewid,linewid+pixel, linemid);
                        fgcol = mix(Robs[rindex].colourB, fgcol, f);
                    }
                }
            }
            
            if(SpH>height){
                float face = 0.7; 
                if(inTri<0.0&&dist<radius*0.9){
                    if(dist<radius*0.7){
                        f = smoothstep(0.0, pixel*5.0, SpH-height);
                        height=mix(height, SpH,  f);
                        normal=mix(normal,vec3( face * cos(rotation) , face * sin(rotation), 0.7), f);
                    } else {
                        f = smoothstep(radius*0.75, radius*0.95, dist);
                        height=mix( SpH, height, f);
                        normal=mix(vec3( face * cos(rotation) , face * sin(rotation), 0.7),normal, f);
                    }
                } 
            }
            
        }
        normal = normal/length(normal);
        /*    // ----  Objects casting shadows on other objects
        for(int i=0;i<numrobs;i++){
            if(i!=rindex&&Robs[i].ison){
                for(int j=0;j<numlights;j++){
                   if(lights[j].casts&&lights[j].ison){
                     if(distance(Robs[i].position, lights[j].position) < distance(Robs[rindex].position, lights[j].position)){
                        vec3 tempBall = Robs[i].position;
                        tempBall.z*=1.2;
                        float beam = linePointLength(tempBall, lights[j].position, vec3(uv.x, uv.y, height)); 
                        float cradius = Robs[i].radius*1.2; // cheating and making the ball bigger so shadow seen more easily
                        float blur = distance(Robs[i].position, vec3(uv.x, uv.y, height))/5.0;
                        float shadow = 0.0;
                        if (beam<=(cradius-blur)){shadow = 1.0;} else {
                            f = smoothstep(cradius-blur, cradius, beam);
                            shadow = mix(1.0,0.0, f);
                        }
                            lights[j].shadow.y = max(shadow, lights[j].shadow.y);
                            }
                        }
                    }
                }
            }
        }
        // ----  Lots of GPU for small improvement, Uncomment to use
        */ 
    }
    
    if(ZoneGround||ZoneWall){
        float shadowheight = 0.0;
        if(ZoneWall){shadowheight = height;};
        for(int i=0;i<numrobs;i++){
            if(Robs[i].ison){
            for(int j=0;j<numlights;j++){
            if(lights[j].casts&&lights[j].ison){
                float beam = linePointLength(Robs[i].position, lights[j].position, vec3(uv.x, uv.y, shadowheight)); 
                float cradius = Robs[i].radius;
                float blur = 0.;
                blur=distance(Robs[i].position, vec3(uv.x, uv.y, shadowheight))/8.0;
                float shadow = 0.0;
                if (beam<=(cradius-blur)){shadow = 1.0;} else {
                    f = smoothstep(cradius-blur, cradius, beam);
                    shadow = mix(1.0,0.0, f);
                }
                lights[j].shadow.x = max(shadow, lights[j].shadow.x);
            }
            }
            }
        }
    }

    vec2 ambientmulti = vec2((min(0.5+(height*3.0), 1.0)),0.5);
    float ambiA = 1.0;float ambiB = 1.0; float ambiC = 0.5;
    ambientmulti *= sqrt((min(ambiC-(courtprox.w*ambiA), ambiB))*(min(ambiC-courtprox.z*ambiA, ambiB))*(min(ambiC-courtprox.y*ambiA, ambiB))*(min(ambiC-courtprox.x*ambiA, ambiB)));
   
    vec3 position = vec3(uv, height);
    vec3 bgtot = vec3(0.0);
    vec3 fgtot = vec3(0.0);
    vec3 sptot = vec3(0.0);
    for(int j=0;j<numlights;j++){
   if(lights[j].ison){
        lights[j].difference = lights[j].position - position;
        lights[j].dist = length(lights[j].difference);
        lights[j].difference = lights[j].difference/lights[j].dist;
        lights[j].amount.x = max(0.0, dot(lights[j].difference, normal));
        lights[j].amount.x = lights[j].amount.x/(lights[j].dist*lights[j].dist);
        lights[j].amount.y = max(0.0, dot(lights[j].difference, bgnormal));
        lights[j].amount.y = lights[j].amount.y/(lights[j].dist*lights[j].dist);
        lights[j].amount.y *= lights[j].intensity * (1.0-lights[j].shadow.x);
        lights[j].amount.x *= lights[j].intensity * (1.0-lights[j].shadow.y);
        bgtot += lights[j].colour*lights[j].amount.y;
        fgtot += lights[j].colour*lights[j].amount.x;
        }
    }

    bgcol*=(robambient.y*ambientmulti.y)+bgtot;
    if(ZoneRob){
        vec3 incident = vec3(0.0, 0.0, -1.0);
        vec3 reflection = reflect(incident, normal);
        for(int j=0;j<numlights;j++){
        if(lights[j].ison){
            lights[j].amount.z = pow(max(0.0, dot(lights[j].difference, reflection)),32.0);
            lights[j].amount.z = lights[j].amount.z/(lights[j].dist*lights[j].dist);
            lights[j].amount.z *= lights[j].intensity * (1.0-lights[j].shadow.y);
            sptot += lights[j].colour*lights[j].amount.z;
            }
        }

        fgcol *= (robambient.x*ambientmulti.x)+fgtot;
        fgcol += sptot;
        
        if(ZoneGround){
            f = smoothstep(radius-pixel, radius, dist);
            col = mix(fgcol,bgcol, f);
        } else {
            col = fgcol;
        }
    } else {
       col = bgcol;
    }
    
    if(tracting){
        float tdist = dradius*0.5;
        float tdistf = distance(Robs[tracter].position.xy, Robs[tractee].position.xy)/2.0;
        float cosr = cos(Robs[tracter].rotation);
        float sinr = sin(Robs[tracter].rotation);
        vec2 tpA = vec2(Robs[tracter].position.x + (tdist * cosr), Robs[tracter].position.y + (tdist * sinr));
        vec2 tpB = vec2(Robs[tracter].position.x + (tdistf * cosr), Robs[tracter].position.y + (tdistf * sinr));
        float tpdist = distance(uv, Robs[tractee].position.xy);
        float tqdist = distance(uv, tpA);
        float tractor = sdBezier(uv, tpA, tpB, Robs[tractee].position.xy);
        float lv = 0.01*tqdist;
        float lw = (0.6*tqdist)+sin((mTime*80.0)+(tqdist*200.0))/80.0;
        vec3 lcol = tcol/3.;
        if(tractor<lw){f = smoothstep(lv, lw, tractor);col = mix(col+lcol,col, f);}
    
        if(rindex==tractee){
            float llw = 0.4;
            vec3 lnorm = vec3(sin(mTime*3.),cos(mTime*11.),cos(mTime*7.));
            float ncola = sin(dot(normal, lnorm));
            float ncolb = sin(dot(normal, lnorm.yzx));
            float ncolc = sin(dot(normal, lnorm.zxy));
            if(ncolc>sin(ncola*5.) && ncolc<sin(ncola*5.)+llw){col += tcol;}
            if(ncola>sin(ncolc*5.) && ncola<sin(ncolc*5.)+llw){col += tcol;}
        }
    }
    
    col = contrast(col, 1.2);
    col = gammaCorrection(col, .95);
    if(outputMode){col = outputColour;}
    fragColor = vec4(col,1.0);
}



    void main() {
      mainImage(outColor, gl_FragCoord.xy);
    }
  `
}
  
const rr = {
  ar: 1,
  pixscale: 1,
  requestId: undefined,
  then:0,
  time:0,
  gl:null,
  program:null,
  vao:null,
  resolutionLoc:null,
  mouseLoc:null,
  timeLoc:null,
  pos0Loc:null,
  pos1Loc:null,
  pos2Loc:null,
  pos3Loc:null,
  pos4Loc:null,
  pos5Loc:null,
  pos6Loc:null,
  pos7Loc:null,
  pos8Loc:null,
  pos9Loc:null,
  pos10Loc:null,
  playerLoc:null,
  hasballLoc:null,
  transformY: function(y){
    return (0.5 + (y/6.0)*0.5);
  },
  transformX: function(x){
    return ((rr.ar/2.0) + (x/10.0)*(rr.ar/2.0));
  },
  render: function(now) {
    rr.requestId = undefined;
    now *= 0.001;  // convert to seconds
    var elapsedTime = Math.min(now - rr.then, 0.1);
    elapsedTime *= physics.delta;
    rr.time += elapsedTime;
    rr.then = now;
    rr.resize();
    input.update();
    rr.gl.viewport(0, 0, rr.gl.canvas.width, rr.gl.canvas.height);
    rr.gl.useProgram(rr.program);
    rr.gl.bindVertexArray(rr.vao);
    physics.animate();
    AI.animate();
    rr.gl.uniform2f(rr.resolutionLoc, rr.gl.canvas.width, rr.gl.canvas.height);
    rr.gl.uniform2f(rr.mouseLoc, input.mx, input.my);
    rr.gl.uniform1f(rr.timeLoc, rr.time);
    rr.gl.uniform2f(rr.pos0Loc,  rr.transformX(go[0].x), rr.transformY(go[0].y));
    rr.gl.uniform3f(rr.pos1Loc,  rr.transformX(go[1].x), rr.transformY(go[1].y), go[1].r);
    rr.gl.uniform3f(rr.pos2Loc,  rr.transformX(go[2].x), rr.transformY(go[2].y), go[2].r);
    rr.gl.uniform3f(rr.pos3Loc,  rr.transformX(go[3].x), rr.transformY(go[3].y), go[3].r);
    rr.gl.uniform3f(rr.pos4Loc,  rr.transformX(go[4].x), rr.transformY(go[4].y), go[4].r);
    rr.gl.uniform3f(rr.pos5Loc,  rr.transformX(go[5].x), rr.transformY(go[5].y), go[5].r);
    rr.gl.uniform3f(rr.pos6Loc,  rr.transformX(go[6].x), rr.transformY(go[6].y), go[6].r);
    rr.gl.uniform3f(rr.pos7Loc,  rr.transformX(go[7].x), rr.transformY(go[7].y), go[7].r);
    rr.gl.uniform3f(rr.pos8Loc,  rr.transformX(go[8].x), rr.transformY(go[8].y), go[8].r);
    rr.gl.uniform3f(rr.pos9Loc,  rr.transformX(go[9].x), rr.transformY(go[9].y), go[9].r);
    rr.gl.uniform3f(rr.pos10Loc,rr.transformX(go[10].x), rr.transformY(go[10].y), go[10].r);

    rr.gl.uniform1i(rr.hasballLoc, physics.possby);

    rr.gl.drawArrays(
        rr.gl.TRIANGLES,
        0,     // offset
        6,     // num vertices to process
    );

    rr.requestFrame();
  },
  requestFrame: function(){
    if (!rr.requestId) {
      rr.requestId = requestAnimationFrame(rr.render);
    }
  },
  cancelFrame: function() {
    if (rr.requestId) {
      cancelAnimationFrame(rr.requestId);
      rr.requestId = undefined;
    }
  },
  resize: function(){
    this.pixscale = window.devicePixelRatio;
    if(window.innerWidth*window.innerHeight > 2000000) {this.pixscale = 2*window.devicePixelRatio}
      if(window.innerWidth*window.innerHeight > 4000000) {this.pixscale = 3*window.devicePixelRatio}
        if(window.innerWidth*window.innerHeight > 8000000) {this.pixscale = 4*window.devicePixelRatio}
    canvas.width  = window.innerWidth/this.pixscale;
    canvas.height = window.innerHeight/this.pixscale; 
    rr.ar = canvas.width/canvas.height;
    canvas.style['image-rendering'] = 'pixelated';
    canvas.style.width  = window.innerWidth+'px';
    canvas.style.height = window.innerHeight+'px';
  },
  init: function(){
    this.resize();
      const canvas = document.querySelector("#canvas");
  rr.gl = canvas.getContext("webgl2");
  if (!rr.gl) {return;}
    rr.program = createProgramFromSources(rr.gl, [shaders.vs, shaders.fs]);
  const positionAttributeLoc = rr.gl.getAttribLocation(rr.program, "a_position");

    rr.resolutionLoc = rr.gl.getUniformLocation(rr.program, "iResolution");
    rr.mouseLoc =rr.gl.getUniformLocation(rr.program, "iMouse");
    rr.timeLoc = rr.gl.getUniformLocation(rr.program, "iTime");
    rr.pos0Loc = rr.gl.getUniformLocation(rr.program, "pos0");
    rr.pos1Loc = rr.gl.getUniformLocation(rr.program, "pos1");
    rr.pos2Loc = rr.gl.getUniformLocation(rr.program, "pos2");
    rr.pos3Loc = rr.gl.getUniformLocation(rr.program, "pos3");
    rr.pos4Loc = rr.gl.getUniformLocation(rr.program, "pos4");
    rr.pos5Loc = rr.gl.getUniformLocation(rr.program, "pos5");
    rr.pos6Loc = rr.gl.getUniformLocation(rr.program, "pos6");
    rr.pos7Loc = rr.gl.getUniformLocation(rr.program, "pos7");
    rr.pos8Loc = rr.gl.getUniformLocation(rr.program, "pos8");
    rr.pos9Loc = rr.gl.getUniformLocation(rr.program, "pos9");
    rr.pos10Loc =rr.gl.getUniformLocation(rr.program, "pos10");

    rr.hasballLoc =rr.gl.getUniformLocation(rr.program, "hasball");

  rr.vao = rr.gl.createVertexArray();
  rr.gl.bindVertexArray(rr.vao);
  const positionBuffer = rr.gl.createBuffer();
  rr.gl.bindBuffer(rr.gl.ARRAY_BUFFER, positionBuffer);
  rr.gl.bufferData(rr.gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), rr.gl.STATIC_DRAW);
  rr.gl.enableVertexAttribArray(positionAttributeLoc);

  rr.gl.vertexAttribPointer(
      positionAttributeLoc,
      2,          // 2 components per iteration
      rr.gl.FLOAT,   // the data is 32bit floats
      false,      // don't normalize the data
      0,          // 0 = move forward size * sizeof(type) each iteration to get the next position
      0,          // start at the beginning of the buffer
  );


  this.requestFrame();
  requestAnimationFrame(this.cancelFrame);
  }
}

const physics = {
    hook: [0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85],
    amount: 11,
    damp: 0.98,
    stopv: 0.001,
    cdist: 3,
    maxvel:[0.13, 0.2, 0.13,0.13,0.13, 0.13, 0.13,0.13, 0.13, 0.13, 0.13],
    agil: 2,
    poss: false,
    possby: 0,
    xv: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    yv: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    zv: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    v: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    xp: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    yp: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    mass: [1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
    radii: [0.2, 0.7, 0.7, 0.7, 0.7, 0.7,0.7, 0.7, 0.7, 0.7, 0.7],
    toplim: [5.1, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7],
    botlim: [-5.1, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7],
    leflim: [-9.3, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9],
    riglim: [9.3, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9],
    goalTop: 1.5,
    goalBottom: -1.5,
    targetx: [0, -6.5, -6.5, -4, -4, -2, 2, 4, 4, 6.5, 6.5],
    targety: [0, 2, -2, 3, -3, 0, 0, -3, 3, -2, 2],
    targetxd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    targetyd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    targeta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    targetamin: 0,
    targetamax: 0,
    anglediff: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    angleinc: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    targetd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ballxd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ballyd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    balld: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    nearestA: 0,
    nearestB: 0,
    vinc: 0.1,
    delta: 1.0,
    slowing: false,
    slow: function(){
      physics.slowing = true;
    },
    fast: function(){
      physics.delta = 1.0;physics.slowing = false;
    },
    checkColl: function(A, B) {
        var dx = go[B].x - go[A].x;
        var dy = go[B].y - go[A].y;
        var dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < this.radii[A] + this.radii[B]) {
            var angle = Math.atan2(dy, dx);
            var cosa = Math.cos(angle);
            var sina = Math.sin(angle);
            var vx1p = cosa * this.xv[A] + sina * this.yv[A];
            var vy1p = cosa * this.yv[A] - sina * this.xv[A];
            var vx2p = cosa * this.xv[B] + sina * this.yv[B];
            var vy2p = cosa * this.yv[B] - sina * this.xv[B];
            var P = vx1p * this.mass[A] + vx2p * this.mass[B];
            var V = vx1p - vx2p;
            vx1p = (P - this.mass[B] * V) / (this.mass[A] + this.mass[B]);
            vx2p = V + vx1p;
            this.xv[A] = cosa * vx1p - sina * vy1p;
            this.yv[A] = cosa * vy1p + sina * vx1p;
            this.xv[B] = cosa * vx2p - sina * vy2p;
            this.yv[B] = cosa * vy2p + sina * vx2p;
            var diff = ((this.radii[A] + this.radii[B]) - dist) / 2;
            var cosd = cosa * diff;
            var sind = sina * diff;
            go[A].x -= cosd;
            go[A].y -= sind;
            go[B].x += cosd;
            go[B].y += sind;
        }
    },
    score: function(side) {
        go[0].x = 0;
        go[0].y = 0;

        this.xv[0] = 0;
        this.yv[0] = 0;
        this.poss = false;
        this.possby = 0;
    },
    animate: function() {

        if(physics.slowing){
          if(physics.delta>0.2){physics.delta*=0.95;}
        }

        for (var i = 0; i < this.amount; i++) {


                if (this.poss && i === 0) {
                    go[i].x = (go[this.possby].x + 1.1*(this.hook[i] * Math.cos(go[this.possby].r - 1.5708)));
                    go[i].y = (go[this.possby].y + 1.1*(this.hook[i] * Math.sin(go[this.possby].r - 1.5708)));
                }
                //if(i<2){
                go[i].x += this.xv[i]*this.delta;
                go[i].y += this.yv[i]*this.delta;
                //}
                this.xv[i] *= this.damp;
                this.yv[i] *= this.damp;

                if (i === 0) {
                  if (!(go[i].y < this.goalTop && go[i].y > this.goalBottom)) {
                           if (go[i].x > this.riglim[i]){
                              go[i].x = this.riglim[i];
                              this.xv[i] = -this.xv[i];
                           }
                           if (go[i].x < this.leflim[i]){
                              go[i].x = this.leflim[i];
                              this.xv[i] = -this.xv[i];
                           }
                  }
                  if (go[i].x > this.riglim[i]+1) {
                      this.score("A");
                  } 
                  if (go[i].x < this.leflim[i]-1) {
                      this.score("B");
                  } 
                } else {
                if (go[i].x > this.riglim[i]) {

                    go[i].x = this.riglim[i];
                    this.xv[i] = -this.xv[i];

                }
                if (go[i].x < this.leflim[i]) {
                    go[i].x = this.leflim[i];
                    this.xv[i] = -this.xv[i];
                }
              }
                if (go[i].y > this.toplim[i]) {
                    go[i].y = this.toplim[i];
                    this.yv[i] = -this.yv[i];
       
                }
                if (go[i].y < this.botlim[i]) {
                    go[i].y = this.botlim[i];
                    this.yv[i] = -this.yv[i];
       
                }

                if ((Math.abs(this.xv[i]) + Math.abs(this.yv[i])) < this.stopv) {
                    this.xv[i] = 0;
                    this.yv[i] = 0;
                }
   
            this.xp[i] = go[i].x;
            this.yp[i] = go[i].y;
            for (var j = i + 1; j < this.amount; j++) {
                this.checkColl(i, j);
            }
            if (i==0){

                if (this.poss) {
                    var xd2 = go[0].x - (go[this.possby].x + (this.hook[i] * Math.cos(go[this.possby].r - 1.5708)));
                    var yd2 = go[0].y - (go[this.possby].y + (this.hook[i] * Math.sin(go[this.possby].r - 1.5708)));
                    if (Math.sqrt((Math.abs(xd2) * Math.abs(xd2) + (Math.abs(yd2) * Math.abs(yd2)))) > 0.3) {
                        this.yv[0] = this.yv[this.possby];
                        this.xv[0] = this.xv[this.possby];
                        this.poss = false;
                        this.possby = 0;

                    }
                }

            } else {
                this.ballxd[i] = go[0].x - go[i].x;
                this.ballyd[i] = go[0].y - go[i].y;
                this.balld[i] = Math.sqrt((Math.abs(this.ballxd[i]) * Math.abs(this.ballxd[i])) + (Math.abs(this.ballyd[i]) * Math.abs(this.ballyd[i])));

                this.targetxd[i] = this.targetx[i] - go[i].x;
                this.targetyd[i] = this.targety[i] - go[i].y;
                this.targeta[i] = Math.atan2(this.targetyd[i], this.targetxd[i]);
   
                go[i].r = go[i].r % 6.283184;
 
                this.targetd[i] = Math.sqrt((Math.abs(this.targetxd[i]) * Math.abs(this.targetxd[i])) + (Math.abs(this.targetyd[i]) * Math.abs(this.targetyd[i])));

                if (this.targetd[i] > this.cdist) {
                    this.v[i] = this.maxvel[i];
                } else if (i == this.nearestA && this.possby != i) {
                    this.v[i] = this.maxvel[i];
                } else if (i == this.nearestB && this.possby != i) {
                    this.v[i] = this.maxvel[i];
                } else if (this.possby == i && i!=1) {
                    this.v[i] = this.maxvel[i];
                } else {
                    this.v[i] = this.maxvel[i] * (this.targetd[i] / this.cdist);
                } 

                //
                var wx = this.v[i] * Math.cos(this.targeta[i]);
                var wy = this.v[i] * Math.sin(this.targeta[i]);
                var netrotation = (go[i].r - 1.5708);

                this.anglediff[i] = this.targeta[i] - netrotation;

                if (this.anglediff[i] > 3.1415927) {
                    this.anglediff[i] -= 6.24318;
                }
                if (this.anglediff[i] < -3.1415927) {
                    this.anglediff[i] += 6.24318;
                }


                if (Math.abs(this.anglediff[i]) < 0.5) {
                    this.yv[i] += (wy - this.yv[i]) / this.agil;
                    this.xv[i] += (wx - this.xv[i]) / this.agil;
                }

                this.angleinc[i] = (this.anglediff[i]) / 10;

                if (this.targetd[i] < 1 && i>1) {

                    this.targetxd[i] = go[0].x - go[i].x;
                    this.targetyd[i] = go[0].y - go[i].y;
                    this.targeta[i] = Math.atan2(this.targetyd[i], this.targetxd[i]);
                    this.anglediff[i] = this.targeta[i] - netrotation;
                    if (this.anglediff[i] > 3.1415927) {
                        this.anglediff[i] -= 6.24318;
                    }
                    if (this.anglediff[i] < -3.1415927) {
                        this.anglediff[i] += 6.24318;
                    }
                    this.angleinc[i] = (this.anglediff[i]) / 10;



                }

                go[i].r += this.angleinc[i]*this.delta;
 
                if (this.possby == i && this.targetd[i] < 1 && i>1) {
                    this.poss = false;
                    this.possby = 0;
                    this.yv[0] = this.yv[i] + 0.4 * Math.sin(go[i].r - 1.5708);
                    this.xv[0] = this.xv[i] + 0.4 * Math.cos(go[i].r - 1.5708);
                    go[0].x += this.xv[0];
                    go[0].y += this.yv[0];
                }

                if (!this.poss) {
                    var xd = go[0].x - (go[i].x + (this.hook[i] * Math.cos(go[i].r - 1.5708)));
                    var yd = go[0].y - (go[i].y + (this.hook[i] * Math.sin(go[i].r - 1.5708)));
                    if (Math.sqrt((Math.abs(xd) * Math.abs(xd) + (Math.abs(yd) * Math.abs(yd)))) < 0.2) {
                        this.poss = true;
                        this.possby = i;
                      
                    }
                }



            }
         
        }
        this.nearestA = 2;
        this.nearestB = 6;
        for (var k = 2; k < 6; k++) {
            if (this.balld[k] < this.balld[this.nearestA]) {
                this.nearestA = k;
            }
        }

        for (var l = 6; l < this.amount; l++) {
            if (this.balld[l] < this.balld[this.nearestB]) {
                this.nearestB = l;
            }
        }
    }
};

var go = [
  {x:0, y:0},
  {x:-2,y:0, r: 1.5708},
  {x:-4,y:2, r: 1.5708},
  {x:-4,y:-2,r: 1.5708},
  {x:-6,y:2, r: 1.5708},
  {x:-6,y:-2,r: 1.5708},
  {x:2, y:0, r:-1.5708},
  {x:4, y:2, r:-1.5708},
  {x:4, y:-2,r:-1.5708},
  {x:6, y:2, r:-1.5708},
  {x:6, y:-2,r:-1.5708}]

var AI = {
    human: 1,
    attackx: [0, 0.2, 0.4, 0.6, 0.8, 1.2, 1.5, 1.5, 1.8, 1.8, 1.9],
    attacky: [0, 1, 1.5, 0.5, 1.7, 0.3, 1.3, 0.7, 0.3, 1.7, 1],
    neutralx: [0, 0.25, 0.25, 0.7, 0.7, 0.8, 1.2, 1.3, 1.3, 1.75, 1.75],
    neutraly: [0, 0.5, 1.5, 0.25, 1.75, 1, 1, 1.75, 0.25, 1.5, 0.5],
    defensex: [0, 0.1, 0.2, 0.2, 0.5, 0.5, 0.8, 1.2, 1.4, 1.6, 1.8],
    defensey: [0, 1, 1.7, 0.3, 0.7, 1.3, 0.3, 1.7, 0.5, 1.5, 1],
    positionx: null,
    positiony: null,

    animate: function() {
        if (physics.poss) {
            if (physics.possby > 5) {
                this.positionx = this.defensex;
                this.positiony = this.defensey;
            } else {
                this.positionx = this.attackx;
                this.positiony = this.attacky;
            }

        } else {
            this.positionx = this.neutralx;
            this.positiony = this.neutraly;
        }

        for (var i = 1; i < 11; i++) {
            if(i!=this.human){
            physics.targetx[i] = this.getx(this.positionx[i]);
            physics.targety[i] = this.gety(this.positiony[i]);
        }
        }
        if(input.gp){
          var gpoffset = 0;
          if(physics.possby==1){gpoffset=0}
            physics.targetx[this.human] = (go[this.human].x-gpoffset) + input.lsx*2;
            physics.targety[this.human] = (go[this.human].y+gpoffset) - input.lsy*2;
          } else {
            physics.targetx[this.human] = ((input.mx/window.innerWidth)*20)-10;
            physics.targety[this.human] = ((input.my/window.innerHeight)*12)-6;
          }
        

        // nearest red and green droids to ball targets ball
        if(physics.nearestA!=this.human){
        physics.targetx[physics.nearestA] = go[0].x;
        physics.targety[physics.nearestA] = go[0].y;
        }
        physics.targetx[physics.nearestB] = go[0].x;
        physics.targety[physics.nearestB] = go[0].y;

        // if ball is in possession, give possessing droid new target
        if (physics.poss&&physics.possby!=this.human) {

            if (physics.possby > 5) {
                physics.targetx[physics.possby] = -5;
                physics.targety[physics.possby] = 0;
            } else {
                physics.targetx[physics.possby] = 5;
                physics.targety[physics.possby] = 0;
            }
        }
        // if possessing droid reaches target, target goal

        // if pointing towards goal, fire ball

        // give human droid control target

        //physics.targetx[this.human] = controls.mx;
        //physics.targety[this.human] = controls.my;
    },

    getx: function(num) {
        var ballx = go[0].x;
        ballx += 9.6;
        if (num < 1) {
            return ((ballx * num) - 9.6);
        } else {
            return ((ballx + ((19.2 - ballx) * (num - 1))) - 9.6);
        }
    },

    gety: function(num) {
        var bally = go[0].y;
        bally += 5.4;
        if (num < 1) {
            return ((bally * num) - 5.4);
        } else {
            return ((bally + ((10.8 - bally) * (num - 1))) - 5.4);
        }
    }
};

function main() {
  input.init();
  rr.init();
}

  // The remaining code is from webgl2fundamentals.org
  // The full version and copyright notice is here:
  // https://webgl2fundamentals.org/webgl/resources/webgl-utils.js

  function error(msg) {console.log(msg)}

  const dst = ["VERTEX_SHADER","FRAGMENT_SHADER"];

  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {
    const errFn = opt_errorCallback || error;
    const shader = gl.createShader(shaderType);
    rr.gl.shaderSource(shader, shaderSource);
    rr.gl.compileShader(shader);
    const compiled = rr.gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!compiled) {
      const lastError = rr.gl.getShaderInfoLog(shader);
      errFn(`Error compiling shader: ${lastError}\n${addLineNumbersWithError(shaderSource, lastError)}`);
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  function createProgram(gl, shdrs, opt_a, opt_l, opt_e) {
    const errFn = opt_e || error;
    const program = rr.gl.createProgram();
    shdrs.forEach(function(shader) { gl.attachShader(program, shader);});
    if (opt_a) { opt_a.forEach(function(attrib, ndx) {
      rr.gl.bindAttribLoc( program, opt_l ? opt_l[ndx] : ndx, attrib);});
    }
    rr.gl.linkProgram(program);

    const linked = rr.gl.getProgramParameter(program, rr.gl.LINK_STATUS);
    if (!linked) {
        const lastError = rr.gl.getProgramInfoLog(program);
        errFn(`Error in program linking: ${lastError}\n${
          shdrs.map(shader => {
            const src = addLineNumbersWithError(rr.gl.getShaderSource(shader));
            const type = rr.gl.getShaderParameter(shader, rr.gl.SHADER_TYPE);
            return `${glEnumToString(rr.gl, type)}:\n${src}`;
          }).join('\n')
        }`);
          gl.deleteProgram(program);
          return null;
        }
        return program;
      }

      function createProgramFromSources(gl, ss, opt_a, opt_l, opt_e) {
        const shdrs = [];
        for (let ii = 0; ii < ss.length; ++ii) {shdrs.push(loadShader(gl, ss[ii], gl[dst[ii]], opt_e));}
        return createProgram(gl, shdrs, opt_a, opt_l, opt_e);
      }
      main();
    </script>
  </body>
</html>

