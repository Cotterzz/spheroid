<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">          
    <title>Index</title>
    <style>
      body {background-color: #000;overflow: hidden;margin: 0px;padding: 0px;}
    </style>
  </head>
  <body>
    <div class="divcanvas">
      <canvas id="canvas"></canvas>
    </div>
    <script>

"use strict";

const input = {
  mx:0,
  my:0,
  lsx:0,
  lsy:0,
  gp:false,
  elem: null,
  update: function() {
    for (const gamepad of navigator.getGamepads()) {
      if (!gamepad) continue;
      for (const [i, button] of gamepad.buttons.entries()) {
        if (button.pressed) {
          //console.log(`Button ${i} [PRESSED]`);
        }
      }
      for (const [i, axis] of gamepad.axes.entries()) {
        //console.log(`${i}: ${axis.toFixed(4)}`);
        //console.log("value", axis + 1);
        if(i==0){input.lsx=axis}
        if(i==1){input.lsy=axis}
        if(Math.abs(input.lsx)<0.1){input.lsx=0}
        if(Math.abs(input.lsy)<0.1){input.lsy=0}
      }
    }
  },
  setMousePosition:function(e) {
    const rect = input.elem.getBoundingClientRect();
    input.mx = e.clientX - rect.left;
    input.my = rect.height - (e.clientY - rect.top) - 1;  // bottom is 0 in WebGL
    //input.mx = input.mx*rr.pixscale;
    //input.my = input.my*rr.pixscale;
  },
  init:function(){
    this.elem = document.querySelector('.divcanvas');
    this.elem.addEventListener('mouseover', rr.requestFrame);
    this.elem.addEventListener('mouseout', rr.cancelFrame);
    this.elem.addEventListener('mousedown', physics.slow);
    this.elem.addEventListener('mouseup', physics.fast);
    this.elem.addEventListener('mousemove', this.setMousePosition);
    this.elem.addEventListener('touchstart', (e) => {
      e.preventDefault();
      rr.requestFrame();
    }, {passive: false});
    this.elem.addEventListener('touchmove', (e) => {
      e.preventDefault();
      this.setMousePosition(e.touches[0]);
    }, {passive: false});
    this.elem.addEventListener('touchend', (e) => {
      e.preventDefault();
      rr.cancelFrame();
    }, {passive: false});
    window.addEventListener("gamepadconnected", (e) => {
      input.gp = true;
      var eg = e.gamepad;
      console.log("GP %d: %s. %d btns, %d axes.",eg.index,eg.id,eg.buttons.length,eg.axes.length,);
    });
  }
}

const shaders = {
  vs:`#version 300 es
    // an attribute is an input (in) to a vertex shader.
    // It will receive data from a buffer
    in vec4 a_position;

    // all shaders have a main function
    void main() {

      // gl_Position is a special variable a vertex shader
      // is responsible for setting
      gl_Position = a_position;
    }
  `,
  fs:`#version 300 es
    precision highp float;

    uniform vec2 iResolution;
    uniform vec2 iMouse;
    uniform float iTime;

    uniform vec2 pos0;
    uniform vec3 pos1;
    uniform vec3 pos2;
    uniform vec3 pos3;
    uniform vec3 pos4;
    uniform vec3 pos5;
    uniform vec3 pos6;
    uniform vec3 pos7;
    uniform vec3 pos8;
    uniform vec3 pos9;
    uniform vec3 pos10;

    // we need to declare an output for the fragment shader
    out vec4 outColor;
    #define numrobs 11
    #define numlights 3
    #define black vec3(0.0,0.0,0.0)
    #define white vec3(1.0,1.0,1.0)
    #define grey vec3(0.5,0.5,0.5)
    #define blue vec3(0.0,0.0,1.0)
    #define red vec3(1.0,0.0,0.0)
    #define lime vec3(0.0,1.0,0.0)
    #define green vec3(0.0,0.7,0.0)
    #define cyan vec3(0.0,1.0,1.0)
    #define purple vec3(1.0,0.0,1.0)
    #define yellow vec3(1.0,1.0,0.0)
    #define orange vec3(1.0,0.6,0.0)
    
    #define porange vec3(1.0,0.8,0.6)
    #define pyellow vec3(0.87,0.87,0.7)
    #define pblue vec3(0.8,0.85,1.0)
    #define pgreen vec3(0.7,0.9,0.7)
    #define pink vec3(0.95,0.75,0.75)
    #define ppurple vec3(1.0,0.7,1.0)
    #define pgrey vec3(0.85,0.85,0.85)
    
    // declared here for use in functions
    float pixel = 0.0;
    vec4 courtprox = vec4(0.0);
    vec2 uv = vec2(0.0);
    float ar = 0.0;
    float f = 0.0; // AA mixing number
    float border = 0.05;
    float bar = 1.0;
    
    struct light
    {
        vec3 colour;
        vec3 position;
        vec3 difference;
        vec3 amount;
        vec2 shadow;
        float dist;
        float intensity;
    };
    
    struct Rob // Round Object. (Players and Ball)
    {
        vec3 position;
        vec3 colourA;
        vec3 colourB;
        float rotation;
        float radius;
    };
    
    vec3 getGroundColour(){
        float linewidth = 0.01;
        float hlinewidth = linewidth/2.0;
        float rhlinewidth = hlinewidth + pixel/2.0;
        vec3 rcol = pgrey;
        if(courtprox.x>-linewidth&&courtprox.x<=0.0||abs(courtprox.y)<linewidth||courtprox.z>-linewidth&&courtprox.z<=0.0||abs(courtprox.w)<linewidth){
            rcol = white;
        }
        float crad = 0.2;
        float dfc = distance(uv, vec2(ar/2.0, 0.5));
        float crdiff = dfc-crad;
        if(crdiff<rhlinewidth ){
            f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));
            rcol = mix(white, pgrey, f);
        }
    
        if(crdiff>=hlinewidth-pixel&&abs(uv.x - (ar/2.0))<=hlinewidth){
            rcol = white;
        }
        dfc = distance(uv, vec2(border*bar, 0.5));
        crdiff = dfc-crad;
        if(crdiff<rhlinewidth ){
            f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));
            rcol = mix(white, rcol, f);
        }
        dfc = distance(uv, vec2(ar-(border*bar), 0.5));
        crdiff = dfc-crad;
        if(crdiff<rhlinewidth ){
            f = smoothstep(rhlinewidth-pixel,rhlinewidth , abs(crdiff));
            rcol = mix(white, rcol, f);
        }
        return rcol;
    }
    
    bool outputMode = false; vec3 outputColour; // Easy way to throw a value at the output for debugging
    void outputValue (in float value){
        outputMode = true;
        if ( value >= 0.0 && value <= 1.0 )
            { outputColour = vec3(value, value, value); }
            else if ( value < 0.0 && value > -1.0 )
            { outputColour = vec3(0.0, 0.0, -value ); }
            else if ( value > 1.0 )
            { outputColour = vec3(1.0-(1.0/value), 1.0, 0.0); }
            else if ( value < -1.0 )
            { outputColour = vec3(1.0-(1.0/-value), 0.0, 1.0); }
    } // Call outputValue with a float and that value will override the pixel output
    void outputValue (in vec3 value){outputMode = true;outputColour = value;} // or directly with a vec3
    
    vec3 contrast(vec3 color, float value) {
      return 0.5 + value * (color - 0.5);
    }
    
    vec3 gammaCorrection (vec3 colour, float gamma) {
      return pow(colour, vec3(1. / gamma));
    }
    
    float linePointLength( in vec3 P, in vec3 A, in vec3 B ){
        vec3 AB = B-A;
        float lenAB = length(AB);
        vec3 D = AB/lenAB;
        vec3 AP = P-A;
        float d = dot(D, AP);
        vec3 X = A + D * dot(P-A, D);
        if(X.z<0.0){return 10.0;} else {return length(X-P);}
    }
    
    vec3 linePoint( in vec3 P, in vec3 A, in vec3 B ){
        vec3 AB = B-A;
        float lenAB = length(AB);
        vec3 D = AB/lenAB;
        vec3 AP = P-A;
        float d = dot(D, AP);
        vec3 X = A + D * dot(P-A, D);
        return X;
    }
    
    // SD Functions from https://iquilezles.org/articles/distfunctions2d/
    
    float sdBox( in vec2 p, in vec2 b )
    {
        vec2 d = abs(p)-b;
        return length(max(d,0.0)) + min(max(d.x,d.y),0.0);
    }
    
    float sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){
      vec2 e0 = p1 - p0;
      vec2 e1 = p2 - p1;
      vec2 e2 = p0 - p2;
    
      vec2 v0 = p - p0;
      vec2 v1 = p - p1;
      vec2 v2 = p - p2;
    
      vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );
      vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );
      vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );
        
        float s = e0.x*e2.y - e0.y*e2.x;
        vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),
                           vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),
                           vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));
    
      return -sqrt(d.x)*sign(d.y);
    }
    // Copyright (c) 2024 John Cotterell johnmdcotterell@gmail.com
    // You may view and edit this code (with this message intact) only on Shadertoy.
    // Anything else requires my permission.
    
    void mainImage( out vec4 fragColor, in vec2 fragCoord )
    {
        // GEOMETRY SETTINGS
        // General
        uv = fragCoord/iResolution.y;      // Normalised resolution
        float height = 0.0;                     // This is the z value to go with our uv's x and y
        ar = iResolution.x/iResolution.y; // Aspect ratio or normalised width
        pixel = 1.0/iResolution.y;        // Size of pixel, for AA
        // Zones. Not exclusive. We can be on more than one for purposes of AA mixing
        bool ZoneRob = false;                  // Are we on the curved fg objects
        bool ZoneGround = false;                // Are we on the ground
        bool ZoneWall = false;                  // Are we on the walls
        bool ZoneGoalWall = false;              // Are we on the goal walls
        bool ZoneInsideWall = false;            // Are we inside wall of goal
        // Background
        border = 0.05;  // Edge border as fraction of screen
        bar = 1.0; // vary border thickness, set to ar, or not, set to 1.0 
        vec4 courtyard = vec4( border*bar, border, ar-(border*bar), 1.0-border); // Edge border limits
        // Difference between current position and edge border limits
        courtprox = vec4( courtyard.x - uv.x, courtyard.y - uv.y, uv.x - courtyard.z, uv.y - courtyard.w);
        float goalwidth = 0.2;                   // width of goal
        float goaltop = 0.5 + (goalwidth/2.0);   // position of goal top
        float goalbottom = 0.5 - (goalwidth/2.0);// position of goal bottom
        float goalprox = max((uv.y-goaltop), (goalbottom-uv.y)); // how far current position is from goal limits
        float wallheightfactor = 1.0;  // multiplier to make up for the fake wall perspective
        // Foreground
        Rob Robs[numrobs];
        float dist = ar; // distance to nearest foreground object
        int rindex = -1; // index of object
        vec2 centre = vec2(ar/2.0, 0.5); // centre of current object
        float radius = 0.0; // radius of current object
        float cradius = 0.34; // radius of circle
        vec2 centreL = vec2((ar/2.0)-(cradius),0.5); // centre of left circle
        vec2 centreR = vec2((ar/2.0)+(cradius),0.5); // centre of right circle
        float segment = 1.256637; // ( 3.1415926 * 2.0 ) / 5.0;
        float rightAng = 1.5708; // ( 3.1415926 * 2.0 ) / 4.0;
        float dradius = 0.055; // default object radius
        float bradius = 0.02; // ball radius
        vec2 distv; // vector from current position to centre
        vec3 normal = vec3(0.0,0.0,1.0); // normal of surface, default is normal of ground
        vec3 bgnormal = vec3(0.0,0.0,1.0); // normal of walls or ground, default is normal of ground
        bool flatTop = false;
        float theight = 0.0;
        float angle = 0.0;
        float speed = iTime;

        vec3 pos[numrobs];
        pos[0] = vec3(pos0, 0.0);
        pos[1] = pos1;
        pos[2] = pos2;
        pos[3] = pos3;
        pos[4] = pos4;
        pos[5] = pos5;
        pos[6] = pos6;
        pos[7] = pos7;
        pos[8] = pos8;
        pos[9] = pos9;
        pos[10] = pos10;
        for(int i=0;i<numrobs;i++){
            pos[i].x = (ar/2.0) + (pos[i].x/10.0)*(ar/2.0);
            pos[i].y = 0.5 + (pos[i].y/6.0)*0.5;
        }
        for(int i=1;i<numrobs;i++){
            Robs[i].radius = dradius;
            Robs[i].position = vec3( pos[i].xy, 0.0);
            Robs[i].rotation = pos[i].z - rightAng;
        }
        int hasball = 2;
        float balldist = bradius*1.1 + dradius;
        Robs[0].position = vec3( pos[0].x, pos[0].y, Robs[0].radius);
        Robs[0].radius = bradius;
        Robs[0].colourA = vec3(1.3,1.3,1.4);
        Robs[1].colourA = porange;
        Robs[2].colourA = pink;
        Robs[3].colourA = pink;
        Robs[4].colourA = pink;
        Robs[5].colourA = pink;
        Robs[6].colourA = pgreen;
        Robs[7].colourA = pgreen;
        Robs[8].colourA = pgreen;
        Robs[9].colourA = pgreen;
        Robs[10].colourA = pgreen;
        
        // COLOUR SETTINGS
        vec3 bgcol; // final background colour
        vec3 fgcol; // final foreground colour
        vec3 col = white;   // final colour
        vec2 robambient = vec2(1.0, 1.0); // the total Ambient effect of round objects. two vlaues for mixing foreground and bg
        
        light lights[numlights];
        lights[0] = light(vec3(1.0,1.0,1.0),vec3(ar*0.5, 0.5 ,0.5),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.1);
        lights[1] = light(vec3(1.0,0.4,0.4),vec3(ar*-0.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.04);
        lights[2] = light(vec3(0.4,1.0,0.4),vec3(ar*1.04, 0.5 ,0.05),vec3(0.0),vec3(0.0),vec2(0.0),0.0, 0.04);
        
        // CASES
        if(courtprox.w>0.0 && courtprox.w*bar>courtprox.z && courtprox.w*bar>courtprox.x){
            // TOP WALL
            bgcol = pgrey;
            bgnormal = vec3(0.0,-1.0,0.0);
            ZoneWall = true;
            height = courtprox.w * wallheightfactor;
        } else if(courtprox.y>0.0 && courtprox.y*bar>courtprox.z && courtprox.y*bar>courtprox.x){
            // BOTTOM WALL
            bgcol = pgrey;
            bgnormal = vec3(0.0,1.0,0.0);
            ZoneWall = true;
            height = courtprox.y *  wallheightfactor;
        } else if(goalprox>0.0 && courtprox.x>0.0 || courtprox.x>(border*bar)/2.0){
            // LEFT WALL
            bgcol = pgrey;
            bgnormal = vec3(1.0,0.0,0.0);
            ZoneWall = true; ZoneGoalWall = true;
            float cph = courtprox.x/2.2;
            if(goalprox<cph && courtprox.x<(border*bar)/2.0 ){
                ZoneInsideWall = true;
                height = goalprox * wallheightfactor;
                if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);} 
            } else {
                height = courtprox.x * wallheightfactor;      
            }
        } else if(goalprox>0.0 && courtprox.z>0.0 || courtprox.z>(border*bar)/2.0){
            // RIGHT WALL
            bgcol = pgrey;
            bgnormal = vec3(-1.0,0.0,0.0);
            ZoneWall = true; ZoneGoalWall = true;
            if(goalprox<courtprox.z/2.2 && courtprox.z<(border*bar)/2.0 ){
                ZoneInsideWall = true;
                height = goalprox * wallheightfactor;
                if(uv.y<0.5){bgnormal = vec3(0.0,1.0,0.0);}else{bgnormal = vec3(0.0,-1.0,0.0);}
            } else {
                height = courtprox.z * wallheightfactor;
              
            }
        } else {
            ZoneGround = true;
            bgcol = getGroundColour();
            bgnormal = vec3(0.0,0.0,1.0);
            //float testbox = sdBox(uv - vec2(0.1,0.5), vec2(0.1,0.1));height=min(testbox, 0.0);
        }
        
        float lightATG = (goaltop-lights[1].position.y)/(lights[1].position.x-courtyard.x);
        float lightATGdist = ( (lights[1].position.x - uv.x) * lightATG) -  (uv.y-lights[1].position.y);
        float lightABG = (goalbottom-lights[1].position.y)/(lights[1].position.x-courtyard.x);
        float lightABGdist =    (uv.y-lights[1].position.y)-( (lights[1].position.x - uv.x) * lightABG);
        float lightAdist = lightABGdist*lightATGdist;
        
        lights[1].shadow.x = 1.0;
        if(goalprox<0.0||ZoneInsideWall){lights[1].shadow.x = 0.0;} else if(lightAdist>0.0){
            lights[1].shadow.x = 0.0;
            f = smoothstep(0.0, 0.2*-courtprox.x, lightAdist);
            lights[1].shadow.x = mix(1.0, 0.0, f);
        }
        
        lightATG = (goaltop-lights[2].position.y)/(lights[2].position.x-courtyard.z);
        lightATGdist = ( (lights[2].position.x - uv.x) * lightATG) -  (uv.y-lights[2].position.y);
        lightABG = (goalbottom-lights[2].position.y)/(lights[2].position.x-courtyard.z);
        lightABGdist =    (uv.y-lights[2].position.y)-( (lights[2].position.x - uv.x) * lightABG);
        lightAdist = lightABGdist*lightATGdist;
        
        lights[2].shadow.x = 1.0;
        if(goalprox<0.0||ZoneInsideWall){lights[2].shadow.x = 0.0;} else if(lightAdist>0.0){
            lights[2].shadow.x= 0.0;
            f = smoothstep(0.0, 0.2*-courtprox.z, lightAdist);
            lights[2].shadow.x = mix(1.0, 0.0, f);
        }
        lights[1].shadow.y = lights[1].shadow.x;
        lights[2].shadow.y = lights[2].shadow.x;
        
        
        for(int i=0;i<numrobs;i++){
            float bdist = distance(uv, Robs[i].position.xy);
            if(bdist<dist){dist=bdist;}
            
            if(bdist<Robs[i].radius&&!ZoneWall){
                dist=bdist;
                radius = Robs[i].radius;
                height = sqrt((radius*radius)-(dist*dist));
                ZoneRob = true;
                rindex = i;
                if(i>5){flatTop=true;}
                if(bdist<Robs[i].radius-pixel){ZoneGround = false;}
            } else {
                float edgedist = distance(uv, Robs[i].position.xy) + (Robs[i].position.z);
                robambient *= 1.0 - (0.5 * pow(0.8/(edgedist/Robs[i].radius),3.0)); // ambient multiplier for outside of object
            }
            
        }
        
        if(ZoneRob){
            fgcol = Robs[rindex].colourA;
            centre = vec2(Robs[rindex].position.x, Robs[rindex].position.y);
            distv = uv - centre;
            normal = vec3(distv.x, distv.y, height)/radius;
            height+=Robs[rindex].position.z;
            
            if(flatTop){
                float tradius = radius/2.5;
                theight = sqrt((radius*radius)-(tradius*tradius));
                if(height>theight){
                    height=theight;
                    normal = vec3(0.0, 1.0, 0.0);
                }
                f = smoothstep(theight-0.01, theight, height);
                normal = mix(normal,vec3(0.0, 0.0, 1.0),  f);
                height = mix(height,theight,  f);
            }
            
            robambient *= (0.6 + normal.z/3.0);// ambient multiplier for inside of object
            float rotation = Robs[rindex].rotation;
            if(rindex>0){
                // Spoiler flap - theres probably a simpler way of doing this
                float SpFoffset = radius*2.0;// set distance from centre to front
                float SpBoffset = radius/1.0;// set distance from centre to back
                float SpFheight = radius*-1.0;// set front and back heights
                float SpBheight = radius*1.4;
                float SpWidth = radius/1.4;// set width, length, height of triangle
                float SpLength = SpFoffset+SpBoffset;
                float SpHeight = SpBheight-SpFheight;
                vec3 SpFc = vec3(centre.x + SpFoffset * cos(rotation),  centre.y + SpFoffset * sin(rotation), 0.0);// get front point F
                vec3 SpFl = SpFc; SpFl.x += (SpWidth * sin(rotation)); SpFl.y -= (SpWidth * cos(rotation));// get front points L and R
                vec3 SpFr = SpFc; SpFr.x -= (SpWidth * sin(rotation)); SpFr.y += (SpWidth * cos(rotation));
                vec3 SpBc = vec3(centre.x - SpBoffset * cos(rotation), centre.y - SpBoffset * sin(rotation), 0.0);// get back point B
                vec3 SpBl = SpBc; SpBl.x += (SpWidth * sin(rotation)); SpBl.y -= (SpWidth * cos(rotation));// get back points L and R
                vec3 SpBr = SpBc; SpBr.x -= (SpWidth * sin(rotation)); SpBr.y += (SpWidth * cos(rotation));
                float SpBD = linePointLength( vec3(uv.x, uv.y, 0.0), vec3(SpBl.x, SpBl.y, 0.0), vec3(SpBr.x, SpBr.y, 0.0) );// get distance from back
                float SpFD = linePointLength( vec3(uv.x, uv.y, 0.0), vec3(SpFl.x, SpFl.y, 0.0), vec3(SpFr.x, SpFr.y, 0.0) );// get distance from front
                float SpH = SpFheight + (SpHeight*(SpFD/SpLength));// get height of current point
                float inTri = sdTriangle(uv, SpFc.xy, SpBr.xy, SpBl.xy);// is point in triangle
                //if(inTri<0.0){outputValue(purple);} // uncomment to test where spoiler triangle is
        
                float lineDist = linePointLength( vec3(uv.x, uv.y, 0.0) , vec3(SpBc.x, SpBc.y, 0.0)  , vec3(SpFc.x, SpFc.y, 0.0)  );
    
                if(SpH>height){// is spoiler higher than dome
                    float face = 0.7; 
                    if(inTri<0.0&&dist<radius*0.9){
                        if(dist<radius*0.7){
                            f = smoothstep(0.0, pixel*5.0, SpH-height);
                            height=mix(height, SpH,  f);
                            normal=mix(normal,vec3( face * cos(rotation) , face * sin(rotation), 0.7), f);
                        } else {
                            f = smoothstep(radius*0.75, radius*0.95, dist);
                            height=mix( SpH, height, f);
                            normal=mix(vec3( face * cos(rotation) , face * sin(rotation), 0.7),normal, f);
                        }
                    } 
                }
                
            }
            normal = normal/length(normal);
            for(int i=0;i<numrobs;i++){
            if(i!=rindex){
                for(int j=0;j<numlights;j++){
                 if(distance(Robs[i].position, lights[j].position) < distance(Robs[rindex].position, lights[j].position)){
                    vec3 tempBall = Robs[i].position;
                    tempBall.z*=1.2;
                    float beam = linePointLength(tempBall, lights[j].position, vec3(uv.x, uv.y, height)); 
                    float cradius = Robs[i].radius*1.2; // cheating and making the ball bigger so shadow seen more easily
                    float blur = distance(Robs[i].position, vec3(uv.x, uv.y, height))/5.0;
                    float shadow = 0.0;
                    if (beam<=(cradius-blur)){shadow = 1.0;} else {
                        f = smoothstep(cradius-blur, cradius, beam);
                        shadow = mix(1.0,0.0, f);
                    }
                    lights[j].shadow.y = max(shadow, lights[j].shadow.y);
                    }
                    }
                }
            }
        }
        
        if(ZoneGround||ZoneWall){
            float shadowheight = 0.0;
            if(ZoneWall){shadowheight = height;};
            for(int i=0;i<numrobs;i++){
                for(int j=0;j<numlights;j++){
                    float beam = linePointLength(Robs[i].position, lights[j].position, vec3(uv.x, uv.y, shadowheight)); 
                    float cradius = Robs[i].radius;
                    float blur = distance(Robs[i].position, vec3(uv.x, uv.y, shadowheight))/5.0;
                    float shadow = 0.0;
                    if (beam<=(cradius-blur)){shadow = 1.0;} else {
                        f = smoothstep(cradius-blur, cradius, beam);
                        shadow = mix(1.0,0.0, f);
                    }
                    lights[j].shadow.x = max(shadow, lights[j].shadow.x);
                }
            }
        }
        
        // calculate and multiply ambient
    
        // these ambient calculations are an approximation based on proximity to walls, ground and objects
        // it gives us a very rough but dynamic AO value
        float ambientmulti = (min(0.5+(height*3.0), 1.0));// if you're on the ground, half of ambient light is removed
        float ambiA = 1.0;float ambiB = 1.0; float ambiC = 0.5;
        ambientmulti *= sqrt((min(ambiC-(courtprox.w*ambiA), ambiB))*(min(ambiC-courtprox.z*ambiA, ambiB))*(min(ambiC-courtprox.y*ambiA, ambiB))*(min(ambiC-courtprox.x*ambiA, ambiB)));
        // and again for each wall
        ambientmulti = robambient.x*ambientmulti;
        
        vec3 position = vec3(uv, height);
        vec3 bgtot = vec3(0.0);
        vec3 fgtot = vec3(0.0);
        vec3 sptot = vec3(0.0);
        for(int j=0;j<numlights;j++){
            lights[j].difference = lights[j].position - position;
            lights[j].dist = length(lights[j].difference);
            lights[j].difference = lights[j].difference/lights[j].dist;
            lights[j].amount.x = max(0.0, dot(lights[j].difference, normal));
            lights[j].amount.x = lights[j].amount.x/(lights[j].dist*lights[j].dist);
            lights[j].amount.y = max(0.0, dot(lights[j].difference, bgnormal));
            lights[j].amount.y = lights[j].amount.y/(lights[j].dist*lights[j].dist);
            lights[j].amount.y *= lights[j].intensity * (1.0-lights[j].shadow.x);
            lights[j].amount.x *= lights[j].intensity * (1.0-lights[j].shadow.y);
            bgtot += lights[j].colour*lights[j].amount.y;
            fgtot += lights[j].colour*lights[j].amount.x;
        }
    
        bgcol*=ambientmulti+bgtot;
        
        if(ZoneRob){
            // calculate and add specular
            vec3 incident = vec3(0.0, 0.0, -1.0);
            vec3 reflection = reflect(incident, normal);
            for(int j=0;j<numlights;j++){
                lights[j].amount.z = pow(max(0.0, dot(lights[j].difference, reflection)),32.0);
                lights[j].amount.z = lights[j].amount.z/(lights[j].dist*lights[j].dist);
                lights[j].amount.z *= lights[j].intensity * (1.0-lights[j].shadow.y);
                sptot += lights[j].colour*lights[j].amount.z;
            }
        
            fgcol *= ambientmulti+fgtot;
            fgcol += sptot; // Add specuialr highlight
        
            // Assign forground or background colour or mix them if on AA border
       
            if(ZoneGround){
                f = smoothstep(radius-pixel, radius, dist);
                col = mix(fgcol,bgcol, f);
            } else {
                col = fgcol;
            }
        } else {
            col = bgcol;
        }
        /*Output to screen
    
        f = smoothstep(0.0, iResolution.x, iMouse.x);
        col = contrast(col, f+1.0);
        if(iMouse.y!=0.0){
            f = smoothstep(0.0, iResolution.y, iMouse.y);
            col = gammaCorrection(col, 0.5 + f*2.0);
        }
        */
        if(outputMode){col = outputColour;}
        fragColor = vec4(col,1.0);
    }

    void main() {
      mainImage(outColor, gl_FragCoord.xy);
    }
  `
}
  
const rr = {
  pixscale: 2,
  requestId: undefined,
  then:0,
  time:0,
  gl:null,
  program:null,
  vao:null,
  resolutionLoc:null,
  mouseLoc:null,
  timeLoc:null,
  pos0Loc:null,
  pos1Loc:null,
  pos2Loc:null,
  pos3Loc:null,
  pos4Loc:null,
  pos5Loc:null,
  pos6Loc:null,
  pos7Loc:null,
  pos8Loc:null,
  pos9Loc:null,
  pos10Loc:null,
  render: function(now) {
    rr.requestId = undefined;
    now *= 0.001;  // convert to seconds
    const elapsedTime = Math.min(now - rr.then, 0.1);
    rr.time += elapsedTime;
    rr.then = now;
    rr.resize();
    input.update();
    rr.gl.viewport(0, 0, rr.gl.canvas.width, rr.gl.canvas.height);
    rr.gl.useProgram(rr.program);
    rr.gl.bindVertexArray(rr.vao);
    physics.animate();
    AI.animate();
    rr.gl.uniform2f(rr.resolutionLoc, rr.gl.canvas.width, rr.gl.canvas.height);
    rr.gl.uniform2f(rr.mouseLoc, input.mx, input.my);
    rr.gl.uniform1f(rr.timeLoc, rr.time);
    rr.gl.uniform2f(rr.pos0Loc, go[0].x, go[0].y);
    rr.gl.uniform3f(rr.pos1Loc, go[1].x, go[1].y, go[1].r);
    rr.gl.uniform3f(rr.pos2Loc, go[2].x, go[2].y, go[2].r);
    rr.gl.uniform3f(rr.pos3Loc, go[3].x, go[3].y, go[3].r);
    rr.gl.uniform3f(rr.pos4Loc, go[4].x, go[4].y, go[4].r);
    rr.gl.uniform3f(rr.pos5Loc, go[5].x, go[5].y, go[5].r);
    rr.gl.uniform3f(rr.pos6Loc, go[6].x, go[6].y, go[6].r);
    rr.gl.uniform3f(rr.pos7Loc, go[7].x, go[7].y, go[7].r);
    rr.gl.uniform3f(rr.pos8Loc, go[8].x, go[8].y, go[8].r);
    rr.gl.uniform3f(rr.pos9Loc, go[9].x, go[9].y, go[9].r);
    rr.gl.uniform3f(rr.pos10Loc, go[10].x, go[10].y, go[10].r);

    rr.gl.drawArrays(
        rr.gl.TRIANGLES,
        0,     // offset
        6,     // num vertices to process
    );

    rr.requestFrame();
  },
  requestFrame: function(){
    if (!rr.requestId) {
      rr.requestId = requestAnimationFrame(rr.render);
    }
  },
  cancelFrame: function() {
    if (rr.requestId) {
      cancelAnimationFrame(rr.requestId);
      rr.requestId = undefined;
    }
  },
  resize: function(){
    canvas.width  = window.innerWidth/this.pixscale;
    canvas.height = window.innerHeight/this.pixscale; 
    canvas.style['image-rendering'] = 'pixelated';
    canvas.style.width  = window.innerWidth+'px';
    canvas.style.height = window.innerHeight+'px';
  },
  init: function(){
    this.resize();
      const canvas = document.querySelector("#canvas");
  rr.gl = canvas.getContext("webgl2");
  if (!rr.gl) {return;}
    rr.program = createProgramFromSources(rr.gl, [shaders.vs, shaders.fs]);
  const positionAttributeLoc = rr.gl.getAttribLocation(rr.program, "a_position");

    rr.resolutionLoc = rr.gl.getUniformLocation(rr.program, "iResolution");
    rr.mouseLoc =rr.gl.getUniformLocation(rr.program, "iMouse");
    rr.timeLoc = rr.gl.getUniformLocation(rr.program, "iTime");
    rr.pos0Loc = rr.gl.getUniformLocation(rr.program, "pos0");
    rr.pos1Loc = rr.gl.getUniformLocation(rr.program, "pos1");
    rr.pos2Loc = rr.gl.getUniformLocation(rr.program, "pos2");
    rr.pos3Loc = rr.gl.getUniformLocation(rr.program, "pos3");
    rr.pos4Loc = rr.gl.getUniformLocation(rr.program, "pos4");
    rr.pos5Loc = rr.gl.getUniformLocation(rr.program, "pos5");
    rr.pos6Loc = rr.gl.getUniformLocation(rr.program, "pos6");
    rr.pos7Loc = rr.gl.getUniformLocation(rr.program, "pos7");
    rr.pos8Loc = rr.gl.getUniformLocation(rr.program, "pos8");
    rr.pos9Loc = rr.gl.getUniformLocation(rr.program, "pos9");
    rr.pos10Loc =rr.gl.getUniformLocation(rr.program, "pos10");

  rr.vao = rr.gl.createVertexArray();
  rr.gl.bindVertexArray(rr.vao);
  const positionBuffer = rr.gl.createBuffer();
  rr.gl.bindBuffer(rr.gl.ARRAY_BUFFER, positionBuffer);
  rr.gl.bufferData(rr.gl.ARRAY_BUFFER, new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]), rr.gl.STATIC_DRAW);
  rr.gl.enableVertexAttribArray(positionAttributeLoc);

  rr.gl.vertexAttribPointer(
      positionAttributeLoc,
      2,          // 2 components per iteration
      rr.gl.FLOAT,   // the data is 32bit floats
      false,      // don't normalize the data
      0,          // 0 = move forward size * sizeof(type) each iteration to get the next position
      0,          // start at the beginning of the buffer
  );


  this.requestFrame();
  requestAnimationFrame(this.cancelFrame);
  }
}

const physics = {
    hook: [0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85, 0.85],
    amount: 11,
    damp: 0.98,
    stopv: 0.001,
    cdist: 3,
    maxvel:[0.13, 0.2, 0.13,0.13,0.13, 0.13, 0.13,0.13, 0.13, 0.13, 0.13],
    agil: 2,
    poss: false,
    possby: 5,
    xv: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    yv: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    zv: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    v: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    xp: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    yp: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    mass: [1, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5],
    radii: [0.2, 0.7, 0.7, 0.7, 0.7, 0.7,0.7, 0.7, 0.7, 0.7, 0.7],
    toplim: [5.1, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7, 4.7],
    botlim: [-5.1, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7, -4.7],
    leflim: [-9.3, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9, -8.9],
    riglim: [9.3, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9, 8.9],
    goalTop: 1.5,
    goalBottom: -1.5,
    targetx: [0, -6.5, -6.5, -4, -4, -2, 2, 4, 4, 6.5, 6.5],
    targety: [0, 2, -2, 3, -3, 0, 0, -3, 3, -2, 2],
    targetxd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    targetyd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    targeta: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    targetamin: 0,
    targetamax: 0,
    anglediff: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    angleinc: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    targetd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ballxd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    ballyd: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    balld: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    nearestA: 0,
    nearestB: 0,
    vinc: 0.1,
    delta: 1.0,
    slow: function(){
      physics.delta = 0.4;
    },
    fast: function(){
      physics.delta = 1.0;
    },
    checkColl: function(A, B) {
        var dx = go[B].x - go[A].x;
        var dy = go[B].y - go[A].y;
        var dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < this.radii[A] + this.radii[B]) {
            var angle = Math.atan2(dy, dx);
            var cosa = Math.cos(angle);
            var sina = Math.sin(angle);
            var vx1p = cosa * this.xv[A] + sina * this.yv[A];
            var vy1p = cosa * this.yv[A] - sina * this.xv[A];
            var vx2p = cosa * this.xv[B] + sina * this.yv[B];
            var vy2p = cosa * this.yv[B] - sina * this.xv[B];
            var P = vx1p * this.mass[A] + vx2p * this.mass[B];
            var V = vx1p - vx2p;
            vx1p = (P - this.mass[B] * V) / (this.mass[A] + this.mass[B]);
            vx2p = V + vx1p;
            this.xv[A] = cosa * vx1p - sina * vy1p;
            this.yv[A] = cosa * vy1p + sina * vx1p;
            this.xv[B] = cosa * vx2p - sina * vy2p;
            this.yv[B] = cosa * vy2p + sina * vx2p;
            var diff = ((this.radii[A] + this.radii[B]) - dist) / 2;
            var cosd = cosa * diff;
            var sind = sina * diff;
            go[A].x -= cosd;
            go[A].y -= sind;
            go[B].x += cosd;
            go[B].y += sind;
        }
    },
    score: function(side) {
        go[0].x = 0;
        go[0].y = 0;

        this.xv[0] = 0;
        this.yv[0] = 0;
        this.poss = false;
        this.possby = 0;
    },
    animate: function() {



        for (var i = 0; i < this.amount; i++) {


                if (this.poss && i === 0) {
                    go[i].x = (go[this.possby].x + 1.1*(this.hook[i] * Math.cos(go[this.possby].r - 1.5708)));
                    go[i].y = (go[this.possby].y + 1.1*(this.hook[i] * Math.sin(go[this.possby].r - 1.5708)));
                }
                //if(i<2){
                go[i].x += this.xv[i]*this.delta;
                go[i].y += this.yv[i]*this.delta;
                //}
                this.xv[i] *= this.damp;
                this.yv[i] *= this.damp;
                if (go[i].x > this.riglim[i]) {

                    go[i].x = this.riglim[i];
                    this.xv[i] = -this.xv[i];

                    if (i === 0) {
                        if (go[i].y < this.goalTop && go[i].y > this.goalBottom) {
                            this.score("A");
                        }
                    }

                }
                if (go[i].x < this.leflim[i]) {
                    go[i].x = this.leflim[i];
                    this.xv[i] = -this.xv[i];
                    if (i === 0) {
                        if (go[i].y < this.goalTop && go[i].y > this.goalBottom) {
                            this.score("B");
                        }
                    }
   
                }
                if (go[i].y > this.toplim[i]) {
                    go[i].y = this.toplim[i];
                    this.yv[i] = -this.yv[i];
       
                }
                if (go[i].y < this.botlim[i]) {
                    go[i].y = this.botlim[i];
                    this.yv[i] = -this.yv[i];
       
                }

                if ((Math.abs(this.xv[i]) + Math.abs(this.yv[i])) < this.stopv) {
                    this.xv[i] = 0;
                    this.yv[i] = 0;
                }
   
            this.xp[i] = go[i].x;
            this.yp[i] = go[i].y;
            for (var j = i + 1; j < this.amount; j++) {
                this.checkColl(i, j);
            }
            if (i==0){

                if (this.poss) {
                    var xd2 = go[0].x - (go[this.possby].x + (this.hook[i] * Math.cos(go[this.possby].r - 1.5708)));
                    var yd2 = go[0].y - (go[this.possby].y + (this.hook[i] * Math.sin(go[this.possby].r - 1.5708)));
                    if (Math.sqrt((Math.abs(xd2) * Math.abs(xd2) + (Math.abs(yd2) * Math.abs(yd2)))) > 0.3) {
                        this.yv[0] = this.yv[this.possby];
                        this.xv[0] = this.xv[this.possby];
                        this.poss = false;
                        this.possby = 0;

                    }
                }

            } else {
                this.ballxd[i] = go[0].x - go[i].x;
                this.ballyd[i] = go[0].y - go[i].y;
                this.balld[i] = Math.sqrt((Math.abs(this.ballxd[i]) * Math.abs(this.ballxd[i])) + (Math.abs(this.ballyd[i]) * Math.abs(this.ballyd[i])));

                this.targetxd[i] = this.targetx[i] - go[i].x;
                this.targetyd[i] = this.targety[i] - go[i].y;
                this.targeta[i] = Math.atan2(this.targetyd[i], this.targetxd[i]);
   
                go[i].r = go[i].r % 6.283184;
 
                this.targetd[i] = Math.sqrt((Math.abs(this.targetxd[i]) * Math.abs(this.targetxd[i])) + (Math.abs(this.targetyd[i]) * Math.abs(this.targetyd[i])));

                if (this.targetd[i] > this.cdist) {
                    this.v[i] = this.maxvel[i];
                } else if (i == this.nearestA && this.possby != i) {
                    this.v[i] = this.maxvel[i];
                } else if (i == this.nearestB && this.possby != i) {
                    this.v[i] = this.maxvel[i];
                } else if (this.possby == i && i!=1) {
                    this.v[i] = this.maxvel[i];
                } else {
                    this.v[i] = this.maxvel[i] * (this.targetd[i] / this.cdist);
                } 

                //
                var wx = this.v[i] * Math.cos(this.targeta[i]);
                var wy = this.v[i] * Math.sin(this.targeta[i]);
                var netrotation = (go[i].r - 1.5708);

                this.anglediff[i] = this.targeta[i] - netrotation;

                if (this.anglediff[i] > 3.1415927) {
                    this.anglediff[i] -= 6.24318;
                }
                if (this.anglediff[i] < -3.1415927) {
                    this.anglediff[i] += 6.24318;
                }


                if (Math.abs(this.anglediff[i]) < 0.5) {
                    this.yv[i] += (wy - this.yv[i]) / this.agil;
                    this.xv[i] += (wx - this.xv[i]) / this.agil;
                }

                this.angleinc[i] = (this.anglediff[i]) / 10;

                if (this.targetd[i] < 1 && i>1) {

                    this.targetxd[i] = go[0].x - go[i].x;
                    this.targetyd[i] = go[0].y - go[i].y;
                    this.targeta[i] = Math.atan2(this.targetyd[i], this.targetxd[i]);
                    this.anglediff[i] = this.targeta[i] - netrotation;
                    if (this.anglediff[i] > 3.1415927) {
                        this.anglediff[i] -= 6.24318;
                    }
                    if (this.anglediff[i] < -3.1415927) {
                        this.anglediff[i] += 6.24318;
                    }
                    this.angleinc[i] = (this.anglediff[i]) / 10;



                }

                go[i].r += this.angleinc[i]*this.delta;
 
                if (this.possby == i && this.targetd[i] < 1 && i>1) {
                    this.poss = false;
                    this.possby = 0;
                    this.yv[0] = this.yv[i] + 0.4 * Math.sin(go[i].r - 1.5708);
                    this.xv[0] = this.xv[i] + 0.4 * Math.cos(go[i].r - 1.5708);
                    go[0].x += this.xv[0];
                    go[0].y += this.yv[0];
                }

                if (!this.poss) {
                    var xd = go[0].x - (go[i].x + (this.hook[i] * Math.cos(go[i].r - 1.5708)));
                    var yd = go[0].y - (go[i].y + (this.hook[i] * Math.sin(go[i].r - 1.5708)));
                    if (Math.sqrt((Math.abs(xd) * Math.abs(xd) + (Math.abs(yd) * Math.abs(yd)))) < 0.2) {
                        this.poss = true;
                        this.possby = i;
                      
                    }
                }



            }
         
        }
        this.nearestA = 2;
        this.nearestB = 6;
        for (var k = 2; k < 6; k++) {
            if (this.balld[k] < this.balld[this.nearestA]) {
                this.nearestA = k;
            }
        }

        for (var l = 6; l < this.amount; l++) {
            if (this.balld[l] < this.balld[this.nearestB]) {
                this.nearestB = l;
            }
        }
    }
};

var go = [
  {x:0, y:0},
  {x:-2,y:0, r: 1.5708},
  {x:-4,y:2, r: 1.5708},
  {x:-4,y:-2,r: 1.5708},
  {x:-6,y:2, r: 1.5708},
  {x:-6,y:-2,r: 1.5708},
  {x:2, y:0, r:-1.5708},
  {x:4, y:2, r:-1.5708},
  {x:4, y:-2,r:-1.5708},
  {x:6, y:2, r:-1.5708},
  {x:6, y:-2,r:-1.5708}]

var AI = {
    human: 1,
    attackx: [0, 0.2, 0.4, 0.6, 0.8, 1.2, 1.5, 1.5, 1.8, 1.8, 1.9],
    attacky: [0, 1, 1.5, 0.5, 1.7, 0.3, 1.3, 0.7, 0.3, 1.7, 1],
    neutralx: [0, 0.25, 0.25, 0.7, 0.7, 0.8, 1.2, 1.3, 1.3, 1.75, 1.75],
    neutraly: [0, 0.5, 1.5, 0.25, 1.75, 1, 1, 1.75, 0.25, 1.5, 0.5],
    defensex: [0, 0.1, 0.2, 0.2, 0.5, 0.5, 0.8, 1.2, 1.4, 1.6, 1.8],
    defensey: [0, 1, 1.7, 0.3, 0.7, 1.3, 0.3, 1.7, 0.5, 1.5, 1],
    positionx: null,
    positiony: null,

    animate: function() {
        if (physics.poss) {
            if (physics.possby > 5) {
                this.positionx = this.defensex;
                this.positiony = this.defensey;
            } else {
                this.positionx = this.attackx;
                this.positiony = this.attacky;
            }

        } else {
            this.positionx = this.neutralx;
            this.positiony = this.neutraly;
        }

        for (var i = 1; i < 11; i++) {
            if(i!=this.human){
            physics.targetx[i] = this.getx(this.positionx[i]);
            physics.targety[i] = this.gety(this.positiony[i]);
        }
        }
        if(input.gp){
          var gpoffset = 0;
          if(physics.possby==1){gpoffset=0}
            physics.targetx[this.human] = (go[this.human].x-gpoffset) + input.lsx*2;
            physics.targety[this.human] = (go[this.human].y+gpoffset) - input.lsy*2;
          } else {
            physics.targetx[this.human] = ((input.mx/window.innerWidth)*20)-10;
            physics.targety[this.human] = ((input.my/window.innerHeight)*12)-6;
          }
        

        // nearest red and green droids to ball targets ball
        if(physics.nearestA!=this.human){
        physics.targetx[physics.nearestA] = go[0].x;
        physics.targety[physics.nearestA] = go[0].y;
        }
        physics.targetx[physics.nearestB] = go[0].x;
        physics.targety[physics.nearestB] = go[0].y;

        // if ball is in possession, give possessing droid new target
        if (physics.poss&&physics.possby!=this.human) {

            if (physics.possby > 5) {
                physics.targetx[physics.possby] = -5;
                physics.targety[physics.possby] = 0;
            } else {
                physics.targetx[physics.possby] = 5;
                physics.targety[physics.possby] = 0;
            }
        }
        // if possessing droid reaches target, target goal

        // if pointing towards goal, fire ball

        // give human droid control target

        //physics.targetx[this.human] = controls.mx;
        //physics.targety[this.human] = controls.my;
    },

    getx: function(num) {
        var ballx = go[0].x;
        ballx += 9.6;
        if (num < 1) {
            return ((ballx * num) - 9.6);
        } else {
            return ((ballx + ((19.2 - ballx) * (num - 1))) - 9.6);
        }
    },

    gety: function(num) {
        var bally = go[0].y;
        bally += 5.4;
        if (num < 1) {
            return ((bally * num) - 5.4);
        } else {
            return ((bally + ((10.8 - bally) * (num - 1))) - 5.4);
        }
    }
};

function main() {
  input.init();
  rr.init();
}

  // The remaining code is from webgl2fundamentals.org
  // The full version and copyright notice is here:
  // https://webgl2fundamentals.org/webgl/resources/webgl-utils.js

  function error(msg) {console.log(msg)}

  const dst = ["VERTEX_SHADER","FRAGMENT_SHADER"];

  function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {
    const errFn = opt_errorCallback || error;
    const shader = gl.createShader(shaderType);
    rr.gl.shaderSource(shader, shaderSource);
    rr.gl.compileShader(shader);
    const compiled = rr.gl.getShaderParameter(shader, gl.COMPILE_STATUS);
    if (!compiled) {
      const lastError = rr.gl.getShaderInfoLog(shader);
      errFn(`Error compiling shader: ${lastError}\n${addLineNumbersWithError(shaderSource, lastError)}`);
      gl.deleteShader(shader);
      return null;
    }
    return shader;
  }

  function createProgram(gl, shdrs, opt_a, opt_l, opt_e) {
    const errFn = opt_e || error;
    const program = rr.gl.createProgram();
    shdrs.forEach(function(shader) { gl.attachShader(program, shader);});
    if (opt_a) { opt_a.forEach(function(attrib, ndx) {
      rr.gl.bindAttribLoc( program, opt_l ? opt_l[ndx] : ndx, attrib);});
    }
    rr.gl.linkProgram(program);

    const linked = rr.gl.getProgramParameter(program, rr.gl.LINK_STATUS);
    if (!linked) {
        const lastError = rr.gl.getProgramInfoLog(program);
        errFn(`Error in program linking: ${lastError}\n${
          shdrs.map(shader => {
            const src = addLineNumbersWithError(rr.gl.getShaderSource(shader));
            const type = rr.gl.getShaderParameter(shader, rr.gl.SHADER_TYPE);
            return `${glEnumToString(rr.gl, type)}:\n${src}`;
          }).join('\n')
        }`);
          gl.deleteProgram(program);
          return null;
        }
        return program;
      }

      function createProgramFromSources(gl, ss, opt_a, opt_l, opt_e) {
        const shdrs = [];
        for (let ii = 0; ii < ss.length; ++ii) {shdrs.push(loadShader(gl, ss[ii], gl[dst[ii]], opt_e));}
        return createProgram(gl, shdrs, opt_a, opt_l, opt_e);
      }
      main();
    </script>
  </body>
</html>

